<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 沙盒专业版 v2.0</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        /* 基础设置 */
        body {
            font-family: 'Microsoft YaHei', 'Inter', sans-serif;
            background: radial-gradient(circle at 10% 20%, #1a1c2e 0%, #0f1016 90%);
            color: #e2e8f0;
            overflow: hidden;
            height: 100vh;
        }

        /* -----------------------
           功能类与动画
           ----------------------- */
        .sandbox-stage {
            perspective: 1500px;
            overflow: hidden;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .sandbox-container {
            transform-style: preserve-3d;
            transform: rotateX(5deg) scale(0.95);
            transition: transform 0.5s ease;
            height: 100%;
        }

        .sandbox-card {
            background: rgba(30, 41, 59, 0.6);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
        }
        .sandbox-card:hover {
            transform: translateY(-8px) translateZ(10px);
            border-color: rgba(139, 92, 246, 0.5);
            box-shadow: 0 20px 40px rgba(0,0,0,0.4);
        }

        .upload-zone {
            background-image: url("data:image/svg+xml,%3csvg width='100%25' height='100%25' xmlns='http://www.w3.org/2000/svg'%3e%3crect width='100%25' height='100%25' fill='none' rx='16' ry='16' stroke='%23475569FF' stroke-width='2' stroke-dasharray='12%2c 12' stroke-dashoffset='0' stroke-linecap='square'/%3e%3c/svg%3e");
            transition: all 0.3s;
        }
        .upload-zone:hover {
            background-image: url("data:image/svg+xml,%3csvg width='100%25' height='100%25' xmlns='http://www.w3.org/2000/svg'%3e%3crect width='100%25' height='100%25' fill='none' rx='16' ry='16' stroke='%23818CF8FF' stroke-width='2' stroke-dasharray='12%2c 12' stroke-dashoffset='0' stroke-linecap='square'/%3e%3c/svg%3e");
            background-color: rgba(30, 41, 59, 0.5);
        }

        /* -----------------------
           AI 面板与切换按钮逻辑
           ----------------------- */
        #ai-panel {
            transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease, transform 0.4s ease;
            width: min(40vw, 560px); /* 根据屏幕宽度自适应，最大 560px */
            transform: translateX(0);
        }

        #ai-panel.collapsed {
            width: 0;
            opacity: 0;
            transform: translateX(100%);
            padding: 0;
            border: none;
        }

        /* --- 核心：侧边栏切换把手 --- */
        #toggle-handle {
            position: absolute;
            top: 50%;
            /* 把手位置跟随面板宽度 */
            right: min(40vw, 560px);
            transform: translateY(-50%);
            z-index: 50;
            cursor: pointer;
            transition: right 0.4s cubic-bezier(0.4, 0, 0.2, 1); /* 动画需与面板一致 */
        }

        /* 收缩状态下的把手位置 */
        #toggle-handle.collapsed {
            right: 0; /* 贴紧屏幕右边缘 */
        }

        /* 唤醒按钮 (右下角圆圈) */
        #wake-btn {
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            transform: scale(0);
            opacity: 0;
        }
        #wake-btn.active {
            transform: scale(1);
            opacity: 1;
        }

        /* --- 新增：对话框拖拽覆盖层 --- */
        #ai-panel.drag-active::after {
            content: '释放以发送文件';
            position: absolute;
            inset: 20px;
            border: 2px dashed #6366f1; /* Indigo-500 */
            background: rgba(15, 23, 42, 0.9);
            backdrop-filter: blur(4px);
            border-radius: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #818cf8;
            font-size: 1.2rem;
            font-weight: bold;
            z-index: 100;
            pointer-events: none; /* 让事件透传 */
        }

        .msg-bubble-ai { background: linear-gradient(145deg, #1e293b, #0f172a); border: 1px solid rgba(255, 255, 255, 0.05); }
        .msg-bubble-user { background: linear-gradient(135deg, #6366f1, #4f46e5); color: white; }

    </style>
</head>
<body class="flex w-full relative">

    <main class="flex-1 relative p-10 flex flex-col sandbox-stage">

        <div class="sandbox-container flex flex-col">
            <header class="flex justify-between items-center mb-10">
                <div>
                    <h1 class="text-3xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-purple-400">
                        <i class="fa-solid fa-cube mr-2"></i>Sandbox OS
                    </h1>
                    <p class="text-slate-300 text-base mt-1">项目 Alpha / 自由视图</p>
                </div>
                <div class="flex space-x-4">
                    <button onclick="document.getElementById('global-upload').click()" class="px-4 py-2 rounded-lg bg-indigo-600 hover:bg-indigo-500 text-white text-sm transition shadow-lg shadow-indigo-500/30 flex items-center">
                        <i class="fa-solid fa-cloud-arrow-up mr-2"></i>上传文件到沙盒
                    </button>
                    <input type="file" id="global-upload" hidden multiple />
                </div>
            </header>

            <div id="files-grid" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6 content-start">
                <!-- 文件列表将动态加载到这里 -->
                
                <div class="upload-zone rounded-2xl flex flex-col items-center justify-center h-56 cursor-pointer group relative" onclick="document.getElementById('global-upload').click()">
                    <div class="w-16 h-16 rounded-full bg-slate-800 flex items-center justify-center mb-4 group-hover:scale-110 transition duration-300">
                        <i class="fa-solid fa-plus text-2xl text-slate-400 group-hover:text-indigo-400"></i>
                    </div>
                    <span class="text-slate-400 font-medium group-hover:text-slate-200">点击或拖拽文件</span>
                    <span class="text-slate-600 text-xs mt-1">支持 PDF, PNG, MD</span>
                </div>

            </div>
        </div>
    </main>

    <div id="toggle-handle" onclick="toggleSidebar()">
        <div class="h-24 w-5 rounded-l-xl bg-slate-800 border-y border-l border-slate-600/50 shadow-[0_0_15px_rgba(0,0,0,0.5)] flex items-center justify-center hover:bg-indigo-900/80 hover:border-indigo-500/50 hover:w-6 transition-all group">
            <i id="toggle-icon" class="fa-solid fa-chevron-right text-slate-400 text-xs group-hover:text-white transition-transform duration-300"></i>
        </div>
    </div>

    <div id="wake-btn" class="fixed right-6 bottom-6 z-50 cursor-pointer" onclick="toggleSidebar()">
        <div class="w-14 h-14 rounded-full bg-gradient-to-r from-indigo-500 to-purple-600 flex items-center justify-center shadow-lg shadow-purple-500/40 hover:scale-110 transition">
            <i class="fa-solid fa-robot text-white text-xl animate-pulse"></i>
        </div>
        <div class="absolute -top-10 left-1/2 transform -translate-x-1/2 bg-slate-800 text-white text-xs px-2 py-1 rounded opacity-0 hover:opacity-100 transition">
            唤醒助手
        </div>
    </div>

    <aside id="ai-panel" class="bg-slate-900/95 border-l border-slate-700/50 flex flex-col relative z-40 shadow-2xl backdrop-blur-md">

        <div class="p-4 border-b border-slate-700/50 flex justify-between items-center bg-slate-900">
            <div class="flex items-center gap-3">
                <div class="w-8 h-8 rounded-lg bg-indigo-600 flex items-center justify-center text-white shadow-lg shadow-indigo-500/20">
                    <i class="fa-solid fa-robot"></i>
                </div>
                <div>
                    <h2 class="font-bold text-slate-100">AI 智能助手</h2>
                    <div class="flex items-center gap-1.5">
                        <span class="w-1.5 h-1.5 rounded-full bg-emerald-400"></span>
                        <span class="text-[10px] text-slate-400">在线 · 随时待命</span>
                    </div>
                </div>
            </div>
            <button onclick="toggleSidebar()" class="w-8 h-8 rounded hover:bg-slate-800 flex items-center justify-center text-slate-400 hover:text-white transition">
                <i class="fa-solid fa-chevrons-right"></i>
            </button>
        </div>

        <div id="chat-messages" class="flex-1 overflow-y-auto p-5 space-y-6 scroll-smooth">
            <div class="flex gap-3">
                <div class="w-8 h-8 rounded-full bg-indigo-500/20 text-indigo-400 flex-shrink-0 flex items-center justify-center text-xs mt-1">AI</div>
                <div class="flex-1">
                    <div class="msg-bubble-ai p-4 rounded-2xl rounded-tl-none text-slate-200 text-base leading-relaxed shadow-sm">
                        你好！您可以直接将沙盒中的文件拖给我，或者点击下方按钮上传附件。
                    </div>
                </div>
            </div>

            <div class="flex gap-3 flex-row-reverse">
                <img src="https://api.dicebear.com/7.x/avataaars/svg?seed=Felix" class="w-8 h-8 rounded-full bg-slate-700 flex-shrink-0 mt-1">
                <div class="flex flex-col items-end gap-2 max-w-[85%]">
                    <div class="bg-slate-800/80 border border-slate-600/50 p-2 pr-4 rounded-xl flex items-center gap-3 w-auto hover:bg-slate-800 transition cursor-pointer">
                           <div class="w-10 h-10 rounded bg-red-500/20 text-red-400 flex items-center justify-center">
                               <i class="fa-regular fa-file-pdf"></i>
                           </div>
                           <div class="text-left">
                               <p class="text-xs text-white font-medium">Q3_Analysis.pdf</p>
                               <p class="text-[10px] text-slate-400">2.4MB</p>
                           </div>
                    </div>
                    <div class="msg-bubble-user p-3.5 rounded-2xl rounded-tr-none text-base shadow-md">
                        帮我分析这份文档里的增长趋势。
                    </div>
                </div>
            </div>
        </div>

        <div class="p-4 bg-slate-900 border-t border-slate-800">
            <!-- 文件解析状态提示区域（固定在输入框上方） -->
            <div id="parsing-status-bar" class="hidden mb-3 px-4 py-2.5 rounded-lg border transition-all">
                <div id="parsing-status-content" class="flex items-center gap-2 text-sm">
                    <!-- 状态内容将动态插入这里 -->
                </div>
            </div>
            
            <div class="relative bg-slate-800 rounded-2xl border border-slate-700 focus-within:border-indigo-500 focus-within:ring-1 focus-within:ring-indigo-500 transition-all">
                <textarea
                    id="chat-input"
                    class="w-full bg-transparent text-slate-200 text-base p-3.5 pr-12 h-14 max-h-40 focus:outline-none resize-none placeholder-slate-500"
                    placeholder="问点什么...（长按空格1秒开始语音输入）"
                    onkeydown="handleKeyDown(event)"
                    oninput="this.style.height = 'auto'; this.style.height = Math.min(this.scrollHeight, 160) + 'px';"
                ></textarea>
                <div class="flex justify-between items-center px-2 pb-2">
                    <div class="flex gap-1">
                        <button onclick="document.getElementById('chat-upload').click()" class="p-2 text-slate-400 hover:text-indigo-400 hover:bg-slate-700/50 rounded-lg transition group relative" title="上传附件">
                            <i class="fa-solid fa-paperclip"></i>
                        </button>
                        <input type="file" id="chat-upload" hidden />
                        <button class="p-2 text-slate-400 hover:text-indigo-400 hover:bg-slate-700/50 rounded-lg transition">
                            <i class="fa-solid fa-microphone"></i>
                        </button>
                    </div>
                    <button id="send-btn" onclick="sendMessage()" class="p-2 bg-indigo-600 hover:bg-indigo-500 text-white rounded-lg shadow-lg text-sm px-4 transition transform active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed">
                        <i class="fa-solid fa-paper-plane"></i>
                    </button>
                </div>
            </div>
        </div>
    </aside>

    <script>
        const API_BASE = 'http://127.0.0.1:5000';
        const panel = document.getElementById('ai-panel');
        const wakeBtn = document.getElementById('wake-btn');
        const handle = document.getElementById('toggle-handle');
        const icon = document.getElementById('toggle-icon');
        const filesGrid = document.getElementById('files-grid');
        const chatMessages = document.getElementById('chat-messages');
        const chatInput = document.getElementById('chat-input');

        function toggleSidebar() {
            const isCollapsed = panel.classList.contains('collapsed');

            if (isCollapsed) {
                // 展开操作
                panel.classList.remove('collapsed');
                handle.classList.remove('collapsed'); // 把手归位到 450px 处
                wakeBtn.classList.remove('active');
                icon.style.transform = 'rotate(0deg)'; // 图标向右
            } else {
                // 收缩操作
                panel.classList.add('collapsed');
                handle.classList.add('collapsed'); // 把手归位到 0px 处
                wakeBtn.classList.add('active');
                icon.style.transform = 'rotate(180deg)'; // 图标向左
            }
        }

        // 获取文件图标
        function getFileIcon(filename) {
            const ext = filename.split('.').pop().toLowerCase();
            const iconMap = {
                'pdf': 'fa-regular fa-file-pdf',
                'png': 'fa-regular fa-image',
                'jpg': 'fa-regular fa-image',
                'jpeg': 'fa-regular fa-image',
                'gif': 'fa-regular fa-image',
                'txt': 'fa-regular fa-file-lines',
                'md': 'fa-regular fa-file-lines',
                'py': 'fa-brands fa-python',
                'js': 'fa-brands fa-js',
                'html': 'fa-brands fa-html5',
                'css': 'fa-brands fa-css3',
                'json': 'fa-regular fa-file-code',
                'csv': 'fa-regular fa-file-csv',
                'doc': 'fa-regular fa-file-word',
                'docx': 'fa-regular fa-file-word',
                'pptx': 'fa-regular fa-file-powerpoint'
            };
            return iconMap[ext] || 'fa-regular fa-file';
        }

        // 获取文件图标颜色
        function getFileIconColor(filename) {
            const ext = filename.split('.').pop().toLowerCase();
            const colorMap = {
                'pdf': 'bg-orange-500/20 text-orange-400',
                'png': 'bg-purple-500/20 text-purple-400',
                'jpg': 'bg-purple-500/20 text-purple-400',
                'jpeg': 'bg-purple-500/20 text-purple-400',
                'gif': 'bg-purple-500/20 text-purple-400',
                'txt': 'bg-blue-500/20 text-blue-400',
                'md': 'bg-blue-500/20 text-blue-400',
                'py': 'bg-yellow-500/20 text-yellow-400',
                'js': 'bg-yellow-500/20 text-yellow-400',
                'html': 'bg-red-500/20 text-red-400',
                'css': 'bg-indigo-500/20 text-indigo-400',
                'json': 'bg-green-500/20 text-green-400',
                'csv': 'bg-emerald-500/20 text-emerald-400',
                'doc': 'bg-blue-500/20 text-blue-400',
                'docx': 'bg-blue-500/20 text-blue-400',
                'pptx': 'bg-orange-500/20 text-orange-400'
            };
            return colorMap[ext] || 'bg-slate-500/20 text-slate-400';
        }

        // 格式化文件大小
        function formatFileSize(bytes) {
            if (!bytes) return '未知大小';
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        // 创建文件卡片（可拖拽）
        function createFileCard(filename) {
            const card = document.createElement('div');
            card.className = 'sandbox-card p-6 rounded-2xl flex flex-col justify-between h-56 cursor-pointer group relative';
            card.draggable = true; // 启用拖拽
            card.dataset.filename = filename; // 存储文件名
            
            // 拖拽开始
            card.addEventListener('dragstart', (e) => {
                e.dataTransfer.effectAllowed = 'copy';
                e.dataTransfer.setData('text/plain', filename);
                e.dataTransfer.setData('application/x-sandbox-file', filename);
                card.style.opacity = '0.5';
            });
            
            // 拖拽结束
            card.addEventListener('dragend', (e) => {
                card.style.opacity = '1';
            });
            
            card.innerHTML = `
                <div class="flex justify-between items-start">
                    <div class="w-12 h-12 rounded-xl ${getFileIconColor(filename)} flex items-center justify-center text-2xl">
                        <i class="${getFileIcon(filename)}"></i>
                    </div>
                    <div class="relative">
                        <button onclick="event.stopPropagation(); showFileMenu(event, '${filename}')" class="p-1 text-slate-500 hover:text-white rounded">
                            <i class="fa-solid fa-ellipsis"></i>
                        </button>
                        <div id="menu-${filename}" class="hidden absolute right-0 mt-1 bg-slate-800 border border-slate-700 rounded-lg shadow-lg z-10 min-w-[120px]">
                            <button onclick="deleteFile('${filename}')" class="w-full text-left px-4 py-2 text-sm text-red-400 hover:bg-slate-700 rounded-t-lg">
                                <i class="fa-solid fa-trash mr-2"></i>删除
                            </button>
                        </div>
                    </div>
                </div>
                <div>
                    <h3 class="font-semibold text-lg text-slate-100 truncate" title="${filename}">${filename}</h3>
                    <p class="text-xs text-slate-400 mt-2">已上传 · 可拖拽到对话框</p>
                </div>
            `;
            return card;
        }

        // 显示文件菜单
        function showFileMenu(event, filename) {
            // 关闭所有其他菜单
            document.querySelectorAll('[id^="menu-"]').forEach(menu => {
                if (menu.id !== `menu-${filename}`) {
                    menu.classList.add('hidden');
                }
            });
            
            const menu = document.getElementById(`menu-${filename}`);
            menu.classList.toggle('hidden');
            
            // 点击外部关闭菜单
            setTimeout(() => {
                document.addEventListener('click', function closeMenu() {
                    menu.classList.add('hidden');
                    document.removeEventListener('click', closeMenu);
                });
            }, 0);
        }

        // 加载文件列表
        async function loadFiles() {
            try {
                const response = await fetch(`${API_BASE}/files`);
                const data = await response.json();
                
                if (data.files && Array.isArray(data.files)) {
                    // 清空现有文件卡片（保留上传区域）
                    const uploadZone = filesGrid.querySelector('.upload-zone');
                    filesGrid.innerHTML = '';
                    
                    // 添加文件卡片
                    data.files.forEach(filename => {
                        const card = createFileCard(filename);
                        filesGrid.appendChild(card);
                    });
                    
                    // 重新添加上传区域
                    if (uploadZone) {
                        filesGrid.appendChild(uploadZone);
                    }
                }
            } catch (error) {
                console.error('加载文件列表失败:', error);
            }
        }

        // 上传文件
        async function uploadFile(file) {
            const formData = new FormData();
            formData.append('file', file);

            try {
                const response = await fetch(`${API_BASE}/upload`, {
                    method: 'POST',
                    body: formData
                });

                const data = await response.json();
                
                if (response.ok) {
                    // 上传成功，重新加载文件列表
                    await loadFiles();
                    return { success: true, message: data.message || '文件上传成功' };
                } else {
                    return { success: false, message: data.error || '文件上传失败' };
                }
            } catch (error) {
                console.error('上传文件失败:', error);
                return { success: false, message: '上传文件时发生错误: ' + error.message };
            }
        }

        // 删除文件
        async function deleteFile(filename) {
            if (!confirm(`确定要删除文件 "${filename}" 吗？`)) {
                return;
            }

            try {
                const response = await fetch(`${API_BASE}/file/${encodeURIComponent(filename)}`, {
                    method: 'DELETE'
                });

                const data = await response.json();
                
                if (response.ok) {
                    // 删除成功，重新加载文件列表
                    await loadFiles();
                    alert('文件删除成功');
                } else {
                    alert('删除失败: ' + (data.error || '未知错误'));
                }
            } catch (error) {
                console.error('删除文件失败:', error);
                alert('删除文件时发生错误: ' + error.message);
            }
        }

        // 文件上传处理
        document.getElementById('global-upload').addEventListener('change', async function() {
            if (this.files.length > 0) {
                const files = Array.from(this.files);
                let successCount = 0;
                let failCount = 0;

                for (const file of files) {
                    const result = await uploadFile(file);
                    if (result.success) {
                        successCount++;
                    } else {
                        failCount++;
                        console.error(`文件 ${file.name} 上传失败:`, result.message);
                    }
                }

                if (successCount > 0) {
                    alert(`成功上传 ${successCount} 个文件${failCount > 0 ? `，${failCount} 个失败` : ''}`);
                } else {
                    alert('所有文件上传失败');
                }

                // 清空input
                this.value = '';
            }
        });

        // 拖拽上传
        const uploadZone = document.querySelector('.upload-zone');
        if (uploadZone) {
            uploadZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadZone.style.backgroundColor = 'rgba(30, 41, 59, 0.7)';
            });

            uploadZone.addEventListener('dragleave', () => {
                uploadZone.style.backgroundColor = '';
            });

            uploadZone.addEventListener('drop', async (e) => {
                e.preventDefault();
                uploadZone.style.backgroundColor = '';
                
                const files = Array.from(e.dataTransfer.files);
                if (files.length > 0) {
                    let successCount = 0;
                    let failCount = 0;

                    for (const file of files) {
                        const result = await uploadFile(file);
                        if (result.success) {
                            successCount++;
                        } else {
                            failCount++;
                        }
                    }

                    if (successCount > 0) {
                        alert(`成功上传 ${successCount} 个文件${failCount > 0 ? `，${failCount} 个失败` : ''}`);
                    } else {
                        alert('所有文件上传失败');
                    }
                }
            });
        }

        // 聊天消息相关变量
        let chatAttachments = [];
        let isParsing = false; // 是否正在解析文件
        
        // ASR 相关变量
        let asrWebSocket = null;
        let audioContext = null;
        let mediaStream = null;
        let audioWorkletNode = null;
        let isRecording = false;
        let spaceKeyDownTime = null;
        let spaceKeyHoldTimer = null;
        let asrDraftElement = null;
        let asrFinalText = '';
        const SPACE_HOLD_THRESHOLD = 1000; // 长按1秒触发
        
        // TTS 相关变量
        let isSpeaking = false;
        let currentUtterances = [];
        let lastSpokenOffset = 0; // 记录已播报文本的长度（字符位置）

        // 显示文件解析状态（固定在输入框上方）
        function showParsingStatus(filename, status) {
            // status: 'parsing' | 'completed' | 'error' | 'clear'
            const statusBar = document.getElementById('parsing-status-bar');
            const statusContent = document.getElementById('parsing-status-content');
            
            if (!statusBar || !statusContent) {
                console.error('解析状态栏元素未找到');
                return;
            }
            
            // 如果状态是 clear，则隐藏状态栏
            if (status === 'clear') {
                statusBar.classList.add('hidden');
                return;
            }
            
            // 显示状态栏
            statusBar.classList.remove('hidden');
            
            let statusHTML = '';
            if (status === 'parsing') {
                // 正在解析：蓝色背景，旋转图标
                statusBar.className = 'mb-3 px-4 py-2.5 rounded-lg border transition-all bg-indigo-500/10 border-indigo-500/30';
                statusHTML = `
                    <i class="fa-solid fa-spinner fa-spin text-indigo-400"></i>
                    <span class="text-slate-200">正在解析文件: <strong class="text-indigo-300">${filename}</strong></span>
                `;
            } else if (status === 'completed') {
                // 解析完成：绿色背景，对勾图标
                statusBar.className = 'mb-3 px-4 py-2.5 rounded-lg border transition-all bg-emerald-500/10 border-emerald-500/30';
                statusHTML = `
                    <i class="fa-solid fa-check-circle text-emerald-400"></i>
                    <span class="text-slate-200">文件 <strong class="text-emerald-300">${filename}</strong> 解析完成，可以发送消息了</span>
                `;
            } else if (status === 'error') {
                // 解析失败：红色背景，警告图标
                statusBar.className = 'mb-3 px-4 py-2.5 rounded-lg border transition-all bg-red-500/10 border-red-500/30';
                statusHTML = `
                    <i class="fa-solid fa-exclamation-circle text-red-400"></i>
                    <span class="text-slate-200">文件 <strong class="text-red-300">${filename}</strong> 解析失败</span>
                `;
            }
            
            statusContent.innerHTML = statusHTML;
        }

        // 解析文件
        async function parseFile(filename) {
            isParsing = true;
            updateSendButtonState();
            
            // 显示正在解析状态
            showParsingStatus(filename, 'parsing');
            
            try {
                const response = await fetch(`${API_BASE}/parse-file`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ filename: filename })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    // 显示解析完成状态
                    showParsingStatus(filename, 'completed');
                } else {
                    // 显示解析失败状态
                    showParsingStatus(filename, 'error');
                }
            } catch (error) {
                console.error('解析文件失败:', error);
                showParsingStatus(filename, 'error');
            } finally {
                isParsing = false;
                updateSendButtonState();
            }
        }

        // 更新发送按钮状态
        function updateSendButtonState() {
            const sendBtn = document.getElementById('send-btn');
            if (sendBtn) {
                if (isParsing) {
                    sendBtn.disabled = true;
                    sendBtn.classList.add('opacity-50', 'cursor-not-allowed');
                } else {
                    sendBtn.disabled = false;
                    sendBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                }
            }
        }

        // 添加消息到聊天
        function appendMessage(text, sender, attachments = [], messageId = null) {
            const messageDiv = document.createElement('div');
            if (messageId) {
                messageDiv.id = messageId;
            }
            messageDiv.className = `flex gap-3 ${sender === 'user' ? 'flex-row-reverse' : ''}`;
            
            if (sender === 'user') {
                messageDiv.innerHTML = `
                    <img src="https://api.dicebear.com/7.x/avataaars/svg?seed=Felix" class="w-8 h-8 rounded-full bg-slate-700 flex-shrink-0 mt-1">
                    <div class="flex flex-col items-end gap-2 max-w-[85%]">
                        ${attachments.length > 0 ? attachments.map(file => `
                            <div class="bg-slate-800/80 border border-slate-600/50 p-2 pr-4 rounded-xl flex items-center gap-3 w-auto hover:bg-slate-800 transition cursor-pointer">
                                <div class="w-10 h-10 rounded ${getFileIconColor(file.name)} flex items-center justify-center">
                                    <i class="${getFileIcon(file.name)}"></i>
                                </div>
                                <div class="text-left">
                                    <p class="text-xs text-white font-medium">${file.name}</p>
                                    <p class="text-[10px] text-slate-400">${formatFileSize(file.size)}</p>
                                </div>
                            </div>
                        `).join('') : ''}
                        ${text ? `<div class="msg-bubble-user p-3.5 rounded-2xl rounded-tr-none text-base shadow-md">
                            ${text}
                        </div>` : ''}
                    </div>
                `;
            } else {
                messageDiv.innerHTML = `
                    <div class="w-8 h-8 rounded-full bg-indigo-500/20 text-indigo-400 flex-shrink-0 flex items-center justify-center text-xs mt-1">AI</div>
                    <div class="flex-1">
                    <div class="msg-bubble-ai p-4 rounded-2xl rounded-tl-none text-slate-200 text-base leading-relaxed shadow-sm">
                            ${text || ''}
                        </div>
                    </div>
                `;
            }
            
            chatMessages.appendChild(messageDiv);
            scrollToChatBottom();
            return messageDiv;
        }

        // 更新消息内容（用于流式输出）
        function updateMessage(messageId, text) {
            const messageDiv = document.getElementById(messageId);
            if (messageDiv) {
                const contentDiv = messageDiv.querySelector('.msg-bubble-ai');
                if (contentDiv) {
                    contentDiv.textContent = text;
                    scrollToChatBottom();
                }
            }
        }

        // 滚动到底部
        function scrollToChatBottom() {
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        // 发送消息
        async function sendMessage() {
            // 如果正在解析，不允许发送
            if (isParsing) {
                return;
            }
            
            // 如果正在播报，停止播报
            if (isSpeaking) {
                stopAllSpeech();
            }
            
            const message = chatInput.value.trim();
            if (!message && chatAttachments.length === 0) return;

            // 检查是否是清除命令
            if (message === '/clear') {
                clearChatHistory();
                chatInput.value = '';
                return;
            }

            // 添加用户消息
            appendMessage(message || '（仅附件）', 'user', chatAttachments);
            
            // 清空输入和附件
            chatInput.value = '';
            chatInput.style.height = 'auto';
            const attachmentsToSend = [...chatAttachments];
            chatAttachments = [];
            
            // 发送消息后，清除解析状态提示（延迟一下，让用户看到完成状态）
            setTimeout(() => {
                showParsingStatus('', 'clear');
            }, 2000);
            
            // 调用后端 API 获取 AI 回复（流式输出）
            try {
                // 重置播报状态，准备新的播报
                lastSpokenOffset = 0;
                
                // 先创建一个空的 AI 消息框
                const aiMessageId = `ai-message-${Date.now()}`;
                appendMessage('', 'ai', [], aiMessageId);
                
                let fullReply = '';
                
                // 如果有附件，使用普通请求
                if (attachmentsToSend.length > 0) {
                    const response = await fetch(`${API_BASE}/chat`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            session_id: 'default',
                            message: message || '（仅附件）',
                            has_attachments: true
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        updateMessage(aiMessageId, data.reply);
                        // 自动播报 AI 回复
                        speakText(data.reply);
                    } else {
                        updateMessage(aiMessageId, `抱歉，发生了错误：${data.error || '未知错误'}`);
                    }
                } else {
                    // 流式输出
                    const response = await fetch(`${API_BASE}/chat`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            session_id: 'default',
                            message: message || '（仅附件）',
                            has_attachments: false
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    
                    while (true) {
                        const { done, value } = await reader.read();
                        
                        if (done) {
                            break;
                        }
                        
                        // 解码数据
                        const chunk = decoder.decode(value, { stream: true });
                        const lines = chunk.split('\n');
                        
                        for (const line of lines) {
                            if (line.startsWith('data: ')) {
                                try {
                                    const data = JSON.parse(line.slice(6));
                                    
                                    if (data.error) {
                                        updateMessage(aiMessageId, `抱歉，发生了错误：${data.error}`);
                                        return;
                                    }
                                    
                                    if (data.chunk) {
                                        fullReply += data.chunk;
                                        updateMessage(aiMessageId, fullReply);
                                        
                                        // 边输出边播报（增量播报）
                                        speakTextIncremental(fullReply);
                                    }
                                    
                                    if (data.done) {
                                        // 流式输出完成
                                        if (data.full_reply) {
                                            updateMessage(aiMessageId, data.full_reply);
                                            // 确保最后的内容也被播报
                                            speakTextIncremental(data.full_reply, true);
                                        } else if (fullReply) {
                                            // 如果没有 full_reply，使用累积的 fullReply
                                            speakTextIncremental(fullReply, true);
                                        }
                                        // 重置已播报位置，为下次播报做准备
                                        lastSpokenOffset = 0;
                                        return;
                                    }
                                } catch (e) {
                                    console.error('解析流式数据失败:', e);
                                }
                            }
                        }
                    }
                }
            } catch (error) {
                console.error('发送消息失败:', error);
                const aiMessageId = `ai-message-${Date.now()}`;
                appendMessage('抱歉，网络连接失败，请检查后端服务是否正常运行。', 'ai', [], aiMessageId);
            }
        }

        // 聊天上传处理（对话框文件独立，上传到服务器但不显示在沙盒）
        document.getElementById('chat-upload').addEventListener('change', async function() {
            if(this.files.length > 0) {
                const files = Array.from(this.files);
                
                // 上传文件到服务器（用于解析），但不显示在沙盒
                for (const file of files) {
                    const formData = new FormData();
                    formData.append('file', file);
                    
                    try {
                        const response = await fetch(`${API_BASE}/upload`, {
                            method: 'POST',
                            body: formData
                        });
                        
                        if (response.ok) {
                            // 上传成功后添加到附件列表
                            chatAttachments.push(file);
                            console.log(`已添加文件到对话附件: ${file.name}`);
                            
                            // 解析文件
                            await parseFile(file.name);
                        } else {
                            console.error(`文件 ${file.name} 上传失败`);
                            alert(`文件 ${file.name} 上传失败`);
                        }
                    } catch (error) {
                        console.error(`上传文件 ${file.name} 时发生错误:`, error);
                        alert(`上传文件 ${file.name} 时发生错误: ${error.message}`);
                    }
                }
                
                // 注意：不调用 loadFiles()，所以不会在沙盒区域显示
            }
            this.value = ''; // 清空input以便可以重复选择同一文件
        });

        // AI 面板拖拽上传功能
        if (panel) {
            panel.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                panel.classList.add('drag-active');
            });

            panel.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                // 只有当离开面板区域时才移除样式
                if (!panel.contains(e.relatedTarget)) {
                    panel.classList.remove('drag-active');
                }
            });

            panel.addEventListener('drop', async (e) => {
                e.preventDefault();
                e.stopPropagation();
                panel.classList.remove('drag-active');

                // 检查是否是沙盒文件拖拽
                const sandboxFilename = e.dataTransfer.getData('application/x-sandbox-file');
                
                if (sandboxFilename) {
                    // 从沙盒拖拽的文件（引用沙盒中已有的文件）
                    console.log('从沙盒拖拽文件到对话框:', sandboxFilename);
                    
                    // 创建文件对象（引用沙盒文件）
                    const file = {
                        name: sandboxFilename,
                        size: 0, // 实际可以从服务器获取
                        isSandboxFile: true // 标记为沙盒文件
                    };
                    
                    chatAttachments.push(file);
                    console.log(`已添加沙盒文件到对话附件: ${sandboxFilename}`);
                    
                    // 解析文件（沙盒文件已经在服务器上）
                    await parseFile(sandboxFilename);
                } else {
                    // 从电脑拖拽的文件（对话框文件，上传到服务器但不显示在沙盒）
                    const files = Array.from(e.dataTransfer.files);
                    if (files.length > 0) {
                        // 上传文件到服务器（用于解析），但不显示在沙盒
                        for (const file of files) {
                            const formData = new FormData();
                            formData.append('file', file);
                            
                            try {
                                const response = await fetch(`${API_BASE}/upload`, {
                                    method: 'POST',
                                    body: formData
                                });
                                
                                if (response.ok) {
                                    // 上传成功后添加到附件列表
                                    chatAttachments.push(file);
                                    console.log(`已添加文件到对话附件: ${file.name}`);
                                    
                                    // 解析文件
                                    await parseFile(file.name);
                                } else {
                                    console.error(`文件 ${file.name} 上传失败`);
                                }
                            } catch (error) {
                                console.error(`上传文件 ${file.name} 时发生错误:`, error);
                            }
                        }
                        // 注意：不调用 loadFiles()，所以不会在沙盒区域显示
                    }
                }
            });
        }

        // ========== ASR 实时语音识别功能 ==========
        
        // 计算 ASR WebSocket 地址
        function getAsrWsUrl() {
            if (window.ASR_WS_URL) return window.ASR_WS_URL;
            const isHttps = location.protocol === 'https:';
            if (isHttps) return `wss://${location.hostname}:5001/ws`;
            return `ws://${location.hostname}:5001/ws`;
        }

        // 初始化 ASR WebSocket 连接
        async function initASRWebSocket() {
            if (asrWebSocket && asrWebSocket.readyState === WebSocket.OPEN) {
                return true;
            }
            
            return new Promise((resolve, reject) => {
                try {
                    const url = getAsrWsUrl();
                    asrWebSocket = new WebSocket(url);
                    
                    asrWebSocket.onopen = () => {
                        console.log('[ASR] WebSocket 已连接');
                        resolve(true);
                    };
                    
                    asrWebSocket.onmessage = async (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            if (data.type === 'partial') {
                                updateASRDraft(data.text, false);
                            } else if (data.type === 'final') {
                                updateASRDraft(data.text, true);
                                asrFinalText = data.text;
                            } else if (data.type === 'error') {
                                console.error('[ASR] 错误:', data.message);
                                showParsingStatus('', 'clear');
                            }
                        } catch (e) {
                            console.error('[ASR] 处理消息异常:', e);
                        }
                    };
                    
                    asrWebSocket.onerror = (error) => {
                        console.error('[ASR] WebSocket 错误:', error);
                        reject(error);
                    };
                    
                    asrWebSocket.onclose = () => {
                        console.log('[ASR] WebSocket 已关闭');
                        asrWebSocket = null;
                    };
                    
                    setTimeout(() => {
                        if (!asrWebSocket || asrWebSocket.readyState !== WebSocket.OPEN) {
                            reject(new Error('WebSocket 连接超时'));
                        }
                    }, 5000);
                } catch (error) {
                    reject(error);
                }
            });
        }

        // 启动 ASR 录音
        async function startASR() {
            if (isRecording) return false;
            
            try {
                const wsReady = await initASRWebSocket();
                if (!wsReady) {
                    console.error('[ASR] WebSocket 连接失败');
                    return false;
                }
                
                // 获取麦克风权限
                mediaStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        sampleRate: 16000,
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: true
                    } 
                });
                
                // 创建 AudioContext
                audioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: 16000
                });
                
                // 创建 MediaStreamAudioSourceNode
                const source = audioContext.createMediaStreamSource(mediaStream);
                
                // 创建 ScriptProcessorNode 处理音频
                const processor = audioContext.createScriptProcessor(4096, 1, 1);
                
                processor.onaudioprocess = (e) => {
                    if (!isRecording || !asrWebSocket || asrWebSocket.readyState !== WebSocket.OPEN) {
                        return;
                    }
                    
                    const inputData = e.inputBuffer.getChannelData(0);
                    const pcmData = new Int16Array(inputData.length);
                    
                    for (let i = 0; i < inputData.length; i++) {
                        const s = Math.max(-1, Math.min(1, inputData[i]));
                        pcmData[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                    }
                    
                    const base64Audio = btoa(String.fromCharCode(...new Uint8Array(pcmData.buffer)));
                    asrWebSocket.send(JSON.stringify({
                        type: 'audio',
                        data: base64Audio
                    }));
                };
                
                source.connect(processor);
                processor.connect(audioContext.destination);
                
                isRecording = true;
                // 草稿气泡已经在 startASR 调用前创建
                console.log('[ASR] ✅ 开始录音');
                return true;
            } catch (error) {
                console.error('[ASR] 启动失败:', error);
                return false;
            }
        }

        // 停止 ASR 录音
        async function stopASR() {
            if (!isRecording) return;
            
            isRecording = false;
            
            // 停止音频流
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
                mediaStream = null;
            }
            
            if (audioContext) {
                await audioContext.close();
                audioContext = null;
            }
            
            // 发送停止信号
            if (asrWebSocket && asrWebSocket.readyState === WebSocket.OPEN) {
                try {
                    asrWebSocket.send(JSON.stringify({ type: 'stop' }));
                } catch (e) {
                    console.error('[ASR] 发送 stop 失败:', e);
                }
            }
            
            // 等待最终结果
            await new Promise(resolve => setTimeout(resolve, 500));
            
            // 如果有最终文本，自动发送
            if (asrFinalText && asrFinalText.trim()) {
                const draftBubble = document.getElementById('asr-draft-bubble');
                if (draftBubble) draftBubble.remove();
                asrDraftElement = null;
                
                chatInput.value = asrFinalText.trim();
                sendMessage();
                asrFinalText = '';
            } else if (asrDraftElement) {
                // 如果没有最终文本，移除草稿
                const draftBubble = document.getElementById('asr-draft-bubble');
                if (draftBubble) draftBubble.remove();
                asrDraftElement = null;
            }
            
            console.log('[ASR] 🛑 停止录音');
        }

        // 创建 ASR 草稿气泡
        function createASRDraft() {
            // 如果已存在，先移除
            const existingBubble = document.getElementById('asr-draft-bubble');
            if (existingBubble) {
                existingBubble.remove();
            }
            
            const messageDiv = document.createElement('div');
            messageDiv.id = 'asr-draft-bubble';
            messageDiv.className = 'flex gap-3 flex-row-reverse';
            
            messageDiv.innerHTML = `
                <img src="https://api.dicebear.com/7.x/avataaars/svg?seed=Felix" class="w-8 h-8 rounded-full bg-slate-700 flex-shrink-0 mt-1">
                <div class="flex flex-col items-end gap-2 max-w-[85%]">
                    <div class="msg-bubble-user p-3.5 rounded-2xl rounded-tr-none text-base shadow-md opacity-80 border-2 border-indigo-400/50">
                        <span class="text-slate-200 flex items-center gap-2">
                            <i class="fa-solid fa-microphone text-indigo-400 animate-pulse"></i>
                            <span>正在识别语音...</span>
                        </span>
                    </div>
                </div>
            `;
            
            chatMessages.appendChild(messageDiv);
            scrollToChatBottom();
            
            // 保存整个消息气泡元素，方便后续更新
            asrDraftElement = messageDiv.querySelector('.msg-bubble-user');
            asrFinalText = '';
            console.log('[ASR] ✅ 草稿气泡已创建');
        }

        // 更新 ASR 草稿内容
        function updateASRDraft(text, isFinal = false) {
            // 通过 ID 查找气泡，确保总是能找到
            const bubble = document.getElementById('asr-draft-bubble');
            if (!bubble) {
                console.warn('[ASR] 草稿气泡不存在，无法更新');
                return;
            }
            
            const contentDiv = bubble.querySelector('.msg-bubble-user');
            if (!contentDiv) {
                console.warn('[ASR] 内容元素不存在，无法更新');
                return;
            }
            
            // 更新文本内容
            if (text && text.trim()) {
                contentDiv.innerHTML = `<span class="text-slate-200">${text}</span>`;
            } else {
                contentDiv.innerHTML = '<span class="text-slate-300 flex items-center gap-2"><i class="fa-solid fa-microphone text-indigo-400 animate-pulse"></i><span>正在识别...</span></span>';
            }
            
            // 更新 asrDraftElement 引用
            asrDraftElement = contentDiv;
            
            if (isFinal) {
                asrFinalText = text;
                bubble.style.opacity = '1';
                contentDiv.classList.remove('border-2', 'border-indigo-400/50');
                console.log('[ASR] ✅ 最终结果已更新:', text);
            }
        }

        // 键盘事件处理（长按空格触发ASR）
        function handleKeyDown(event) {
            // Enter 键发送消息（仅在输入框内）
            if (event.key === 'Enter' && !event.shiftKey && document.activeElement === chatInput) {
                event.preventDefault();
                sendMessage();
                return;
            }
        }

        // 全局键盘事件监听（用于长按空格触发ASR）
        document.addEventListener('keydown', (event) => {
            // 如果正在输入框内打字，不触发 ASR
            if (document.activeElement === chatInput) {
                return;
            }
            
            // 长按空格1秒触发 ASR
            if (event.code === 'Space' && !event.repeat) {
                event.preventDefault();
                spaceKeyDownTime = Date.now();
                
                console.log('[ASR] 空格键按下，开始计时...');
                
                spaceKeyHoldTimer = setTimeout(async () => {
                    console.log('[ASR] ✅ 长按空格1秒，触发ASR');
                    
                    // 如果正在播放 TTS，先停止
                    if (isSpeaking) {
                        stopAllSpeech();
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                    
                    // 先创建草稿气泡，显示"正在识别..."
                    createASRDraft();
                    
                    const success = await startASR();
                    if (!success) {
                        // 如果启动失败，更新草稿气泡显示错误
                        const draftBubble = document.getElementById('asr-draft-bubble');
                        if (draftBubble) {
                            const contentDiv = draftBubble.querySelector('.msg-bubble-user');
                            if (contentDiv) {
                                contentDiv.innerHTML = '<span class="text-red-400 flex items-center gap-2"><i class="fa-solid fa-exclamation-circle"></i><span>ASR 启动失败，请检查服务是否运行（端口 5001）</span></span>';
                            }
                            setTimeout(() => {
                                draftBubble.remove();
                                asrDraftElement = null;
                            }, 3000);
                        } else {
                            asrDraftElement = null;
                        }
                    }
                }, SPACE_HOLD_THRESHOLD);
            }
        });

        // 键盘释放事件
        document.addEventListener('keyup', (event) => {
            if (event.code === 'Space') {
                event.preventDefault();
                
                if (spaceKeyHoldTimer) {
                    clearTimeout(spaceKeyHoldTimer);
                    spaceKeyHoldTimer = null;
                }
                
                if (isRecording) {
                    stopASR();
                }
            }
        });

        // ========== TTS 语音播报功能 ==========
        
        // 停止所有 TTS 播报
        function stopAllSpeech() {
            if (window.speechSynthesis) {
                window.speechSynthesis.cancel();
            }
            isSpeaking = false;
            currentUtterances = [];
            lastSpokenOffset = 0; // 重置已播报位置
        }

        // 清除对话记录
        async function clearChatHistory() {
            try {
                // 停止所有播报
                stopAllSpeech();
                
                // 清除前端聊天消息（保留欢迎消息）
                const welcomeMessage = chatMessages.querySelector('.flex.gap-3:first-child');
                chatMessages.innerHTML = '';
                if (welcomeMessage) {
                    chatMessages.appendChild(welcomeMessage);
                }
                
                // 调用后端清除会话
                const response = await fetch(`${API_BASE}/chat/clear`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        session_id: 'default'
                    })
                });
                
                if (response.ok) {
                    console.log('[Chat] 对话记录已清除');
                }
            } catch (error) {
                console.error('清除对话记录失败:', error);
            }
        }

        // TTS 增量播报（边输出边播报，只在"完整句子"时触发）
        function speakTextIncremental(text, isFinal = false) {
            if (!text || !window.speechSynthesis) {
                console.log('[TTS] 跳过播报：无文本或浏览器不支持');
                return;
            }
            
            // 提取纯文本（去除Markdown等格式）
            const cleanText = text.replace(/[#*_`\[\]()]/g, '').trim();
            if (!cleanText) {
                console.log('[TTS] 跳过播报：清理后文本为空');
                return;
            }
            
            // 取出本次尚未播报的新增部分
            if (lastSpokenOffset >= cleanText.length) {
                console.log('[TTS] 跳过播报：已播报完所有内容');
                return;
            }
            const pendingText = cleanText.slice(lastSpokenOffset);
            if (!pendingText.trim()) {
                console.log('[TTS] 跳过播报：待播报文本为空');
                return;
            }
            
            console.log('[TTS] 准备播报，已播报位置:', lastSpokenOffset, '待播报文本长度:', pendingText.length);
            
            // 只对"以句号/感叹号/问号结尾的完整句子"做增量播报
            const sentenceRegex = /[^。！？.!?]+[。！？.!?]/g;
            let match;
            let consumedLength = 0;
            const sentencesToSpeak = [];
            
            // 重置正则表达式的 lastIndex，确保从头开始匹配
            sentenceRegex.lastIndex = 0;
            while ((match = sentenceRegex.exec(pendingText)) !== null) {
                const sentence = match[0].trim();
                if (sentence) {
                    sentencesToSpeak.push(sentence);
                    // 计算已匹配文本的实际长度（包括匹配到的完整句子）
                    consumedLength = match.index + match[0].length;
                }
            }
            
            // 如果不是最终结果，且没有完整句子，就先不播报，等下一个 chunk
            if (!isFinal && sentencesToSpeak.length === 0) {
                console.log('[TTS] 等待完整句子，暂不播报');
                return;
            }
            
            // 非最终结果：只播报完整句子部分，留下尾巴（未成句部分）到下次再播
            // 最终结果：尾巴（如果有）也一起播报
            if (isFinal) {
                const tailText = pendingText.slice(consumedLength).trim();
                if (tailText) {
                    sentencesToSpeak.push(tailText);
                    consumedLength = pendingText.length;
                }
            }
            
            if (sentencesToSpeak.length === 0) {
                console.log('[TTS] 没有可播报的句子');
                return;
            }
            
            console.log('[TTS] 开始播报', sentencesToSpeak.length, '个句子:', sentencesToSpeak);
            
            // 播报所有待播句子
            sentencesToSpeak.forEach((sentence) => {
                if (!sentence) return;
                
                if (!isSpeaking) {
                    isSpeaking = true;
                }
                
                const utterance = new SpeechSynthesisUtterance(sentence);
                utterance.lang = 'zh-CN';
                utterance.rate = 1.0;
                utterance.pitch = 1.0;
                utterance.volume = 1.0;
                
                utterance.onend = () => {
                    // 检查是否所有播报都完成了
                    if (window.speechSynthesis.speaking === false) {
                        isSpeaking = false;
                    }
                };
                
                utterance.onerror = () => {
                    if (window.speechSynthesis.speaking === false) {
                        isSpeaking = false;
                    }
                };
                
                currentUtterances.push(utterance);
                window.speechSynthesis.speak(utterance);
            });
            
            // 更新"已播报到哪里了"的位置
            lastSpokenOffset = lastSpokenOffset + consumedLength;
            if (isFinal) {
                lastSpokenOffset = cleanText.length;
            }
        }

        // TTS 朗读文本（完整文本，一次性播报）
        function speakText(text) {
            if (!text || !window.speechSynthesis) return;
            
            // 停止之前的播报
            stopAllSpeech();
            
            isSpeaking = true;
            
            // 提取纯文本（去除Markdown等格式）
            const cleanText = text.replace(/[#*_`\[\]()]/g, '').trim();
            if (!cleanText) return;
            
            // 分句朗读
            const sentences = cleanText.match(/[^。！？.!?]+[。！？.!?]*/g) || [cleanText];
            
            sentences.forEach((sentence, index) => {
                const trimmed = sentence.trim();
                if (!trimmed) return;
                
                const utterance = new SpeechSynthesisUtterance(trimmed);
                utterance.lang = 'zh-CN';
                utterance.rate = 1.0;
                utterance.pitch = 1.0;
                utterance.volume = 1.0;
                
                if (index === sentences.length - 1) {
                    utterance.onend = () => {
                        isSpeaking = false;
                        lastSpokenOffset = cleanText.length;
                    };
                }
                
                utterance.onerror = () => {
                    isSpeaking = false;
                };
                
                currentUtterances.push(utterance);
                window.speechSynthesis.speak(utterance);
            });
        }

        // 修改 sendMessage 函数，在流式输出完成后自动播报
        // 在流式输出完成的地方添加 TTS 播报
        // 找到 updateMessage 调用完成的地方，添加 speakText

        // 页面加载时获取文件列表
        loadFiles();
        
        // 初始化发送按钮状态
        updateSendButtonState();
    </script>
</body>
</html>